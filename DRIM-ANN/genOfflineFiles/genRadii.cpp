/*
Author: KMC20
Date: 2024/7/5
Function: Generate the radii of each cluster offline for DRIM-ANN.
Usage:
 > g++ genRadii.cpp -std=c++11 -I ../DRIM-ANN/common/inc -o genRadii
 > ./genRadii -D 128 -M 8 -p ../DRIM-ANN/offlineFiles/sift100m.clusters -c ../DRIM-ANN/offlineFiles/sift100m.centroids -b ../DRIM-ANN/offlineFiles/sift100m.codebook -a ../DRIM-ANN/offlineFiles/sift100m.clusterSizes -r ../DRIM-ANN/offlineFiles/sift100m.radii
 > rm genRadii
*/

#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <unistd.h>
#include "request.h"

#define NR_JOB_PARALLEL 64

using UINT64 = unsigned long long;


ADDRTYPE getPointsAmount(const char *const pointsFileName, const uint32_t pointSize) {
    FILE *fp = fopen(pointsFileName, "rb");
    if (fp == NULL) {
        printf("Failed to open the input point file: %s! Exit now!\n", pointsFileName);
        exit(-1);
    }
    fseek(fp, 0, SEEK_END);
    ADDRTYPE pointsAmt = ftell(fp) / pointSize;
    fclose(fp);
    return pointsAmt;
}

template <typename T>
void load1DPointsFromFile(const char *const pointsFileName, std::vector<T> &points) {
    FILE *fp = fopen(pointsFileName, "rb");
    if (fp == NULL) {
        printf("Failed to open the input point file: %s! Exit now!\n", pointsFileName);
        exit(-1);
    }
    fseek(fp, 0, SEEK_END);
    long long int pointsElemSize = ftell(fp) / sizeof(T);
    fseek(fp, 0, SEEK_SET);
    if (fread(points.data(), sizeof(T), pointsElemSize, fp) == 0 && pointsElemSize != 0) {
        fclose(fp);
        printf("The input point file: %s is an empty file! Exit now!\n", pointsFileName);
        exit(-1);
    }
    fclose(fp);
}

void saveDataToFile(const char *const dataFileName, const void *data, const size_t size, const size_t nmemb) {
    FILE *fp = fopen(dataFileName, "wb");
    if (fp == NULL) {
        printf("Failed to open the output point file: %s! Exit now!\n", dataFileName);
        exit(-1);
    }
    fwrite(data, size, nmemb, fp);
    fclose(fp);
}

__attribute__((noreturn)) static void usage(FILE *f, int exit_code, const char *exec_name) {
    /* clang-format off */
    fprintf(f,
            "\nusage: %s [-p <points_path>] [-c <centroids_path>] [-b <codebook_path>] [-a <cluster_size_path>] [-r <radius_result_path>] [-D <number_of_dimension>] [-M <number_of_subvectors>]\n"
            "\n"
            "\t-p \tthe path to the cluster location (default: clusters.bin)\n"
            "\t-c \tthe path to the centroid location (default: centroids.bin)\n"
            "\t-b \tthe path to the codebook location (default: codebook.bin)\n"
            "\t-a \tthe path to the cluster size location (default: clusterSizes.bin)\n"
            "\t-r \tthe path to the radius location (default: radii.bin)\n"
            "\t-D \tthe number of dimensions of input points (default: 128)\n"
            "\t-M \tthe number of subvectors generated by each point (default: 8)\n"
            "\t-h \tshow the usage message\n",
            exec_name);
    /* clang-format on */
    exit(exit_code);
}

static void verify_path_exists(const char *path) {
    if (access(path, R_OK)) {
        fprintf(stderr, "path '%s' does not exist or is not readable (errno: %i)\n", path, errno);
        exit(EXIT_FAILURE);
    }
}

static void parse_args(int argc, char **argv, uint32_t *dimAmt, uint32_t *sliceAmt, std::string &clustersFileName, std::string &centroidsFileName, std::string &codebookFileName, std::string &clusterSizesFileName, std::string &radiiFileName) {
    int opt;
    extern char *optarg;
    while ((opt = getopt(argc, argv, "hD:M:p:c:b:a:r:")) != -1) {
        switch (opt) {
            case 'p':
                clustersFileName = optarg;
                break;
            case 'D':
                *dimAmt = (uint32_t)atoi(optarg);
                break;
            case 'M':
                *sliceAmt = (uint32_t)atoi(optarg);
                break;
            case 'c':
                centroidsFileName = optarg;
                break;
            case 'b':
                codebookFileName = optarg;
                break;
            case 'a':
                clusterSizesFileName = optarg;
                break;
            case 'r':
                radiiFileName = optarg;
                break;
            case 'h':
                usage(stdout, EXIT_SUCCESS, argv[0]);
            default:
                usage(stderr, EXIT_FAILURE, argv[0]);
        }
    }
    verify_path_exists(clustersFileName.c_str());
    verify_path_exists(centroidsFileName.c_str());
    verify_path_exists(codebookFileName.c_str());
    verify_path_exists(clusterSizesFileName.c_str());
}


int main(int argc, char **argv)
{
    uint32_t dimAmt = 128;
    uint32_t sliceAmt = 8;
    std::string clustersFileName = "clusters.bin";
    std::string centroidsFileName = "centroids.bin";
    std::string codebookFileName = "codebook.bin";
    std::string clusterSizesFileName = "clusterSizes.bin";
    std::string radiiFileName = "radii.bin";
    parse_args(argc, argv, &dimAmt, &sliceAmt, clustersFileName, centroidsFileName, codebookFileName, clusterSizesFileName, radiiFileName);
    std::vector<POINTTYPE> clusters(getPointsAmount(clustersFileName.c_str(), sizeof(POINTTYPE)));
    std::vector<ELEMTYPE> centroids(getPointsAmount(centroidsFileName.c_str(), sizeof(ELEMTYPE)));
    std::vector<ELEMTYPE> codebook(getPointsAmount(codebookFileName.c_str(), sizeof(ELEMTYPE)));
    std::vector<CLUSTER_SIZES_TYPE> clusterSizes(getPointsAmount(clusterSizesFileName.c_str(), sizeof(CLUSTER_SIZES_TYPE)));
    std::vector<SQUAREROOTDISTTYPE> radii(clusterSizes.size(), 0);
    load1DPointsFromFile(clustersFileName.c_str(), clusters);
    load1DPointsFromFile(centroidsFileName.c_str(), centroids);
    load1DPointsFromFile(codebookFileName.c_str(), codebook);
    load1DPointsFromFile(clusterSizesFileName.c_str(), clusterSizes);
    uint32_t codebookEntryAmt = codebook.size() / dimAmt;
    uint32_t svDimAmt = dimAmt / sliceAmt;  // Note: only support the case that `dimAmt` is divisible by `sliceAmt`
    std::vector<ADDRTYPE> CBRowBase(sliceAmt + 1);
    CBRowBase[0] = 0;
    for (size_t CBRowBaseIdx = 1, CBRowBaseEnd = CBRowBase.size(); CBRowBaseIdx < CBRowBaseEnd; ++CBRowBaseIdx) {
        CBRowBase[CBRowBaseIdx] = CBRowBase[CBRowBaseIdx - 1] + codebookEntryAmt * svDimAmt;
    }
    for (size_t clusterIdx = 0, clusterAmt = clusterSizes.size(), clusterPointElemCnt = 0; clusterIdx < clusterAmt; ++clusterIdx) {
        SQUAREROOTDISTTYPE maxDis = 0;
        for (size_t pointIdx = 0; pointIdx < clusterSizes[clusterIdx]; ++pointIdx) {
            VECSUMTYPE dist = 0, partDis;
            for (size_t dimCnt = 0, sliceCnt = 0; sliceCnt < sliceAmt; ++sliceCnt) {
                for (size_t CBIdx = CBRowBase[sliceCnt] + clusters[clusterPointElemCnt++] * svDimAmt, svDimCnt = 0; svDimCnt < svDimAmt; ++svDimCnt, ++CBIdx, ++dimCnt) {
                    // partDis = codebook[CBIdx] > centroids[dimCnt] ? (VECSUMTYPE)(codebook[CBIdx]) - centroids[dimCnt] : (VECSUMTYPE)(centroids[dimCnt]) - codebook[CBIdx];
                    partDis = codebook[CBIdx];  // The codebook encodes the residuals between cluster points and centroids. If the clusters are not encoded by residual, switch to the line above
                    dist += partDis * partDis;
                }
            }
            if (dist > maxDis)
                maxDis = dist;
        }
        radii[clusterIdx] = std::ceil(std::sqrt(maxDis));
    }
    saveDataToFile(radiiFileName.c_str(), radii.data(), sizeof(SQUAREROOTDISTTYPE), radii.size());
    return 0;
}