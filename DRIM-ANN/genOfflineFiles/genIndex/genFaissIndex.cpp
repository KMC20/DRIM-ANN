// Note: this program has been modified to generate IVF-PQ index files by KMC20 on 2024/3/25
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <cstdio>
#include <cstdlib>
#include <sys/time.h>
#include <regex>

#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFPQ.h>
#include <faiss/index_io.h>
#include <faiss/gpu/GpuAutoTune.h>
#include <faiss/gpu/GpuCloner.h>
#include <faiss/gpu/GpuIndexFlat.h>
#include <faiss/gpu/GpuIndexIVFPQ.h>
#include <faiss/gpu/StandardGpuResources.h>
#include <faiss/gpu/utils/DeviceUtils.h>

#include <getopt.h>
#include <numeric>
#include <iostream>
#include <string.h>
#include <cmath>

using idx_t = faiss::idx_t;
using ELEMTYPE = unsigned char;
using ADDRTYPE = unsigned long long int;

ADDRTYPE getPointsAmount(const char *const pointsFileName, const uint32_t dimAmt) {
    FILE *fp = fopen(pointsFileName, "rb");
    if (fp == NULL) {
        printf("Failed to open the input point file: %s! Exit now!\n", pointsFileName);
        exit(-1);
    }
    fseek(fp, 0, SEEK_END);
    ADDRTYPE pointsAmt = ftell(fp) / (sizeof(ELEMTYPE) * dimAmt);
    fclose(fp);
    return pointsAmt;
}

void loadPointsFromFile(const char *const pointsFileName, ELEMTYPE *points) {
    FILE *fp = fopen(pointsFileName, "rb");
    if (fp == NULL) {
        printf("Failed to open the input point file: %s! Exit now!\n", pointsFileName);
        exit(-1);
    }
    fseek(fp, 0, SEEK_END);
    long long int pointsElemSize = ftell(fp) / sizeof(ELEMTYPE);
    fseek(fp, 0, SEEK_SET);
    if (fread(points, sizeof(ELEMTYPE), pointsElemSize, fp) == 0) {
        fclose(fp);
        printf("The input point file: %s is an empty file! Exit now!\n", pointsFileName);
        exit(-1);
    }
    fclose(fp);
}

void clearDataFile(const char *const dataFileName) {
    FILE *fp = fopen(dataFileName, "wb");
    fclose(fp);
}

void saveDataToFile(const char *const dataFileName, const void *data, const size_t size, const size_t nmemb) {
    FILE *fp = fopen(dataFileName, "ab");
    if (fp == NULL) {
        printf("Failed to open the output point file: %s! Exit now!\n", dataFileName);
        exit(-1);
    }
    fwrite(data, size, nmemb, fp);
    fclose(fp);
}

template<typename T>
void padding(const std::vector<T> &oldData, const uint64_t &oldStrideByte, const uint64_t &newStrideByte, std::vector<T> &newData) {
    memset(reinterpret_cast<T *>(newData.data()), 0, newData.size() * sizeof(T));
    uint64_t oldStride = oldStrideByte / sizeof(T), newStride = newStrideByte / sizeof(T);
    const T *oldPt = reinterpret_cast<const T *>(oldData.data()), *oldPtEnd = reinterpret_cast<const T *>(oldData.data()) + oldData.size();
    for (T *newPt = reinterpret_cast<T *>(newData.data()); oldPt < oldPtEnd; oldPt += oldStride, newPt += newStride) {
        memmove(newPt, oldPt, oldStrideByte);
    }
}

void parseGPUs(std::vector<int> &GPUs, const std::string &GPUsettings) {
    std::regex pat("[[:digit:]]+");
    std::smatch curGPU;
    std::string::const_iterator GPUsettingStart = GPUsettings.begin();
    std::string::const_iterator GPUsettingEnd = GPUsettings.end();
    while (regex_search(GPUsettingStart, GPUsettingEnd, curGPU, pat)) {
        GPUs.push_back(std::stoi(curGPU[0]));
        GPUsettingStart = curGPU[0].second;
    }
}

__attribute__((noreturn)) static void usage(FILE *f, int exit_code, const char *exec_name) {
    /* clang-format off */
    fprintf(f,
            "\nusage: %s [-x <base_path>] [-p <points_path>] [-c <centroids_path>] [-b <codebook_path>] [-a <cluster_size_path>] [-i <index_path>] [-g <GPU_IDs>] [-D <dimensions>] [-C <number_of_clusters>] [-M <number_of_subvectors>]\n"
            "\n"
            "\t-x \tthe path to the base dataset location (default: base.bin)\n"
            "\t-p \tthe path to the cluster location (default: clusters.bin)\n"
            "\t-c \tthe path to the centroid location (default: centroids.bin)\n"
            "\t-b \tthe path to the codebook location (default: codebook.bin)\n"
            "\t-a \tthe path to the cluster size location (default: clusterSizes.bin)\n"
            "\t-i \tthe path to the index file location. If the file does not exist, it will be created by this program (default: index.bin)\n"
            "\t-g \tthe list of available GPU IDs (default: [0,1])\n"
#ifdef PERF_EVAL
            "\t-F \tthe frequency of DPUs (default: 450000000)\n"
#endif
            "\t-D \tthe dimensions (default: 128)\n"
            "\t-C \tthe number of clusters (default: 1000)\n"
            "\t-M \tthe number of subvectors generated by each point (default: 8)\n"
            "\t-h \tshow the usage message\n",
            exec_name);
    /* clang-format on */
    exit(exit_code);
}

static void parse_args(int argc, char **argv, long long int *dimension, int *nlist, int *sliceAmt, char **xbFileName, char **clustersFileName, char **centroidsFileName, char **codebookFileName, char **clusterSizesFileName, char **idxFileName, char **GPUIDsString) {
    int opt;
    extern char *optarg;
    while ((opt = getopt(argc, argv, "hD:C:M:x:p:c:b:a:i:g:")) != -1) {
        switch (opt) {
            case 'D':
                *dimension = (long long int)atoi(optarg);
                break;
            case 'C':
                *nlist = (int)atoi(optarg);
                break;
            case 'M':
                *sliceAmt = (int)atoi(optarg);
                break;
            case 'x':
                *xbFileName = optarg;
                break;
            case 'p':
                *clustersFileName = optarg;
                break;
            case 'c':
                *centroidsFileName = optarg;
                break;
            case 'b':
                *codebookFileName = optarg;
                break;
            case 'a':
                *clusterSizesFileName = optarg;
                break;
            case 'i':
                *idxFileName = optarg;
                break;
            case 'g':
                *GPUIDsString = optarg;
                break;
            case 'h':
                usage(stdout, EXIT_SUCCESS, argv[0]);
            default:
                usage(stderr, EXIT_FAILURE, argv[0]);
        }
    }
}


int main(int argc, char **argv) {  // e.g. ./genFaissIndex -D 128 -C 100 -x ~/datasets/SIFT100M/sift100m.bvecs -g [0,1,2,3,4,5,6,7,8,9,10]
                                   //  or  ./genFaissIndex -D 128 -C 16384 -M 16 -x ~/datasets/SIFT100M/sift100m.bvecs -p ../../DRIM-ANN/offlineFiles/sift100m.clusters -c ../../DRIM-ANN/offlineFiles/sift100m.centroids -b ../../DRIM-ANN/offlineFiles/sift100m.codebook -a ../../DRIM-ANN/offlineFiles/sift100m.clusterSizes -g [3,4,5,8]
    char *xbFileName = const_cast<char *>("base.bin");
    long long int d = 128;  // dimension
    int nlist = 1000;
    char *clustersFileName = const_cast<char *>("clusters.bin");
    char *centroidsFileName = const_cast<char *>("centroids.bin");
    char *codebookFileName = const_cast<char *>("codebook.bin");
    char *clusterSizesFileName = const_cast<char *>("clusterSizes.bin");
    char *idxFileName = const_cast<char *>("index.bin");
    char *GPUIDsString = const_cast<char *>("[0,1]");
    int m = 8;  // bytes per vector

    parse_args(argc, argv, &d, &nlist, &m, &xbFileName, &clustersFileName, &centroidsFileName, &codebookFileName, &clusterSizesFileName, &idxFileName, &GPUIDsString);

    faiss::IndexFlatL2 quantizer(d);
    faiss::IndexIVFPQ cpu_index_obj(&quantizer, d, nlist, m, 8);

    int ngpus;
    std::vector<faiss::gpu::GpuResourcesProvider*> res;
    std::vector<int> devs;
    if (argc > 2) {
        std::vector<int> GPUIDs;
        parseGPUs(GPUIDs, GPUIDsString);
        ngpus = GPUIDs.size();
        for (auto GPUID: GPUIDs) {
            res.push_back(new faiss::gpu::StandardGpuResources);
            devs.push_back(GPUID);
        }
    } else {
        ngpus = faiss::gpu::getNumDevices();
        for (int i = 0; i < ngpus; ++i) {
            res.push_back(new faiss::gpu::StandardGpuResources);
            devs.push_back(i);
        }
    }
    printf("Number of GPUs: %d\n", ngpus);

    faiss::Index* gpu_index = nullptr, *cpu_index = &cpu_index_obj;
    long start, end;
    struct timeval timecheck;
    {
        FILE *fp = fopen(idxFileName, "rb");
        if (fp == NULL) {
            long long int nb = getPointsAmount(xbFileName, d);  // database size
            float* xb = new float[d * nb];
            {
                ELEMTYPE *prixb = new ELEMTYPE[d * nb];
                loadPointsFromFile(xbFileName, prixb);
                for (long long int i = 0; i < nb; i++) {
                    for (long long int j = 0; j < d; j++)
                        xb[d * i + j] = prixb[d * i + j];
                }
                delete []prixb;
            }
            if (ngpus > 0) {
                gpu_index = faiss::gpu::index_cpu_to_gpu_multiple(res, devs, &cpu_index_obj);
                gettimeofday(&timecheck, NULL);
                start = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                gpu_index->train(nb, xb);
                gettimeofday(&timecheck, NULL);
                end = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                printf("Train time: %lf\n", double(end - start) / 1e6);
                gettimeofday(&timecheck, NULL);
                start = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                gpu_index->add(nb, xb);
                gettimeofday(&timecheck, NULL);
                end = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                printf("Add time: %lf\n", double(end - start) / 1e6);
                gettimeofday(&timecheck, NULL);
                start = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                faiss::write_index(faiss::gpu::index_gpu_to_cpu(gpu_index), idxFileName);
                gettimeofday(&timecheck, NULL);
                end = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                printf("Save time: %lf\n", double(end - start) / 1e6);
            } else {
                gettimeofday(&timecheck, NULL);
                start = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                cpu_index->train(nb, xb);
                gettimeofday(&timecheck, NULL);
                end = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                printf("Train time: %lf\n", double(end - start) / 1e6);
                gettimeofday(&timecheck, NULL);
                start = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                cpu_index->add(nb, xb);
                gettimeofday(&timecheck, NULL);
                end = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                printf("Add time: %lf\n", double(end - start) / 1e6);
                gettimeofday(&timecheck, NULL);
                start = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                faiss::write_index(cpu_index, idxFileName);
                gettimeofday(&timecheck, NULL);
                end = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
                printf("Save time: %lf\n", double(end - start) / 1e6);
            }
            delete[] xb;
        } else {
            fclose(fp);
            gettimeofday(&timecheck, NULL);
            start = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
            cpu_index = faiss::read_index(idxFileName);
            gettimeofday(&timecheck, NULL);
            end = (long)timecheck.tv_sec * 1e6 + (long)timecheck.tv_usec;
            printf("Load time: %lf\n", double(end - start) / 1e6);
        }
    }

    faiss::IndexIVFPQ* cpu_index_p = gpu_index != nullptr ? dynamic_cast<faiss::IndexIVFPQ*>(faiss::gpu::index_gpu_to_cpu(gpu_index)) : dynamic_cast<faiss::IndexIVFPQ*>(cpu_index);
    faiss::IndexFlatL2 *cpu_quantizer_p = reinterpret_cast<faiss::IndexFlatL2*>(cpu_index_p->quantizer);

    // 1. Save centroids
    {
        float *centroidsFp = reinterpret_cast<float *>(cpu_quantizer_p->codes.data());
        ADDRTYPE centroidsAmt = cpu_quantizer_p->codes.size() / sizeof(float);
        std::vector<ELEMTYPE> quantiCentroids(centroidsAmt);
        #pragma omp parallel for num_threads(NR_JOB_PER_RANK)
        for (uint64_t clusterId = 0; clusterId < centroidsAmt; ++clusterId, ++centroidsFp)
            quantiCentroids[clusterId] = *centroidsFp;
        clearDataFile(centroidsFileName);
        saveDataToFile(centroidsFileName, quantiCentroids.data(), sizeof(ELEMTYPE), centroidsAmt);
    }
    // 2. Save clusters
    std::vector<uint32_t> clusterSizes(cpu_index_p->invlists->nlist);
    #pragma omp parallel for num_threads(NR_JOB_PER_RANK)
    for (uint64_t clusterId = 0; clusterId < cpu_index_p->invlists->nlist; ++clusterId) {
        clusterSizes[clusterId] = cpu_index_p->invlists->list_size(clusterId);
    }
    clearDataFile(clustersFileName);
    for (uint64_t clusterId = 0; clusterId < cpu_index_p->invlists->nlist; ++clusterId) {
        saveDataToFile(clustersFileName, cpu_index_p->invlists->get_codes(clusterId), cpu_index_p->invlists->code_size, clusterSizes[clusterId]);
    }
    // 3. Save clusterSizes
    clearDataFile(clusterSizesFileName);
    saveDataToFile(clusterSizesFileName, clusterSizes.data(), sizeof(uint32_t), clusterSizes.size());
    // 4. Save codebook
    std::vector<ELEMTYPE> quantiCentroids(cpu_index_p->pq.centroids.size());
    #pragma omp parallel for num_threads(NR_JOB_PER_RANK)
    for (uint64_t centroidId = 0; centroidId < cpu_index_p->pq.centroids.size(); ++centroidId) {
        quantiCentroids[centroidId] = ELEMTYPE(cpu_index_p->pq.centroids[centroidId]);
    }
    if ((sizeof(ELEMTYPE) * (d / m) & 7) != 0) {
        uint32_t oldStride = sizeof(ELEMTYPE) * (d / m);
        uint32_t newStride = std::ceil(sizeof(ELEMTYPE) * (d / m) / 8.0) * 8;
        std::vector<ELEMTYPE> newCodebook(quantiCentroids.size() / oldStride * newStride);
        padding(quantiCentroids, oldStride, newStride, newCodebook);
        quantiCentroids.resize(newCodebook.size());
        memmove(reinterpret_cast<ELEMTYPE *>(quantiCentroids.data()), reinterpret_cast<const ELEMTYPE *>(newCodebook.data()), sizeof(ELEMTYPE) * quantiCentroids.size());
    }
    clearDataFile(codebookFileName);
    saveDataToFile(codebookFileName, quantiCentroids.data(), sizeof(ELEMTYPE), quantiCentroids.size());

    delete gpu_index;
    for (int i = 0; i < ngpus; i++) {
        delete res[i];
    }

    return 0;
}
